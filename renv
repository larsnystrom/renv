#!/bin/bash
# Remote Environment Management

# Constants
declare -r TAB=$'\t'
declare -r EOL=$'\n'
declare -r USAGE="Usage: `basename $0` config[:get|:set|:unset] [--host ssh_host|--remote git_remote] [--env-file path]"

# Usage
[ $# -eq 0 ] && { echo "$USAGE"; exit 1; }

# Defaults
REMOTE=
ENV_FILE=""
PARAMS_COUNT=0
HOST=

# Arguments
while [[ $# > 1 ]]; do
    key="$1"
    shift

    case $key in
        -r|--remote)
            REMOTE="$1"
            shift
            ;;
        -e|--env-file)
            ENV_FILE="$1"
            shift
            ;;
        -h|--host)
            HOST="$1"
            shift
            ;;
        *)
            PARAMS[$PARAMS_COUNT]="$key"
            PARAMS_COUNT=$((PARAMS_COUNT+1))
            ;;
    esac
done

if [ -n "$1" ]; then
    PARAMS[$PARAMS_COUNT]="$1"
    PARAMS_COUNT=$((PARAMS_COUNT+1))
fi

if [ $PARAMS_COUNT == 0 ]; then
    echo "$USAGE"
    exit 1
fi

if [ -z "$HOST" ] && [ -n "$REMOTE" ]; then
    # Require git
    if ! hash git > /dev/null 2>&1; then
        echo "Git must be installed to use a Git remote."
        exit 1
    fi

    # Check if inside a git repository
    git status > /dev/null 2>&1
    if [ $? == 128 ]; then
        echo "Not a git repository, or other git error. Run \"git status\" for more information."
        exit 1
    fi

    # Get git remote
    GIT_REMOTE=`git remote -v | grep "$REMOTE" | grep "fetch"`
    if [[ $GIT_REMOTE = *$EOL* ]]; then
        echo "Ambigous remote \"$REMOTE\"."
        exit 1
    fi

    if [ -z "$GIT_REMOTE" ]; then
        echo "\"$REMOTE\" is not a remote in this repository."
        exit 1
    fi

    HOST=`expr "$GIT_REMOTE" : "^.*${TAB}\(.*\):.* "`
    REMOTE_DIR=`expr "$GIT_REMOTE" : "^.*${TAB}.*@.*:\(.*\) "`

    # If ENV_FILE isn't set, try remote .env file
    if [ -z "$ENV_FILE" ]; then
        ENV_FILE="${REMOTE_DIR}/.env"
    fi
fi

# Last check
if [ -z "$HOST" ]; then
    echo "No host or remote specified."
    exit 1
fi
if [ -z "$ENV_FILE" ]; then
    echo "No remote .env file specified."
    exit 1
fi

APP=`expr "$HOST" : '.*@\([^:/]*\)'`

# Check if file exists on remote
if ! ssh $HOST stat $ENV_FILE \> /dev/null 2\>\&1; then
    echo "\"$ENV_FILE\" doesn't exist on the remote. Try specifying the path with the --env-file argument."
    exit 1
fi

case $PARAMS[0] in
    config:get*)
        if [ "$PARAMS_COUNT" != 2 ]; then
            echo "No variable specified."
            exit 1
        fi

        KEY="${PARAMS[1]}"
        ENV=`ssh $HOST cat "$ENV_FILE" | grep "^\<export\> ${KEY}="`
        VAL=`expr "$ENV" : "^\<export\> [^=]*=\(.*\)"`

        echo "$VAL"
        ;;
    config:set*)
        if [ "$PARAMS_COUNT" != 2 ]; then
            echo "No variable specified."
            exit 1
        fi

        KEY=`expr "${PARAMS[1]}" : "\([^=]*\)=.*"`
        NEW_VAL=`expr "${PARAMS[1]}" : "[^=]*=\(.*\)"`

        ENV=`ssh $HOST cat "$ENV_FILE" | grep "^\<export\> ${KEY}="`
        VAL=`expr "$ENV" : "^\<export\> [^=]*=\(.*\)"`

        if [ "$VAL" == "$NEW_VAL" ]; then
            echo "${KEY}=${NEW_VAL}"
            exit 0
        fi

        if [ -n "$ENV" ]; then
            ssh $HOST "sed -i \"s|export ${KEY}=${VAL}|export ${KEY}=${NEW_VAL}|\" \"$ENV_FILE\""
        else
            echo "export ${KEY}=${NEW_VAL}" | ssh $HOST "cat >> $ENV_FILE"
        fi

        echo "${KEY}=${NEW_VAL}"
        ;;
    config:unset*)
        if [ "$PARAMS_COUNT" != 2 ]; then
            echo "No variable specified."
            exit 1
        fi

        KEY="${PARAMS[1]}"

        read -p "Do you wish to unset \"$KEY\"? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborting"
            exit 0
        fi

        ENV=`ssh $HOST cat "$ENV_FILE" | grep "^\<export\> ${KEY}="`

        if [ -z "$ENV" ]; then
            exit 0
        fi

        ssh $HOST "sed -i \"/$KEY/d\" $ENV_FILE"
        ;;
    config*)
        ENV=`ssh $HOST cat "$ENV_FILE"`
        KEYS=()
        VALS=()
        MAX_LEN=0
        while read -r line; do
            if [ -n "$line" ]; then
                KEYS+=(`expr "$line" : "^\<export\> \([^=]*\)=.*"`)
                VALS+=(`expr "$line" : "^\<export\> [^=]*=\(.*\)"`)
            fi

            # Get the length of the last string.
            # [Get the string length at (length of array - 1)]
            LENGTH_LAST=${#KEYS[${#KEYS[@]} - 1]}
            if [ "$LENGTH_LAST" -gt "$MAX_LEN" ]; then
                MAX_LEN=${LENGTH_LAST}
            fi
        done <<< "$ENV"

        echo "=== $APP Config Vars"
        for i in "${!KEYS[@]}"; do
            KEY=${KEYS[${i}]}
            LEN=${#KEY}

            echo -n "${KEY}:"
            for k in $(seq $LEN $MAX_LEN); do
                echo -n " "
            done
            echo ${VALS[${i}]}
        done
        ;;
    *)
        echo "Invalid command \"${PARAMS[0]}\""
        exit 1
        ;;
esac
